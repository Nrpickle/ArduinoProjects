/*
 SD card datalogger (with advanced features)

 Nick McComb [nick@nickmccomb.net]
 March 2015
 
 @desc 
 This program records all of the analog ports onto an SD Card. It _requires_ no hardware to run besides the Ethernet Shield, but you can also add a SF RTC on the I2C bus to enable RTC logging (Make sure to enable/disable the "RTC_ENABLE"). Adafruit's RTC has been used as well. Basically if it is an DS1307 with the I2C address 0x68, then it will work.
 
 Also, ensure that you have properly configured the time/date of your RTC, this script does not do that for you.
 */

#include <SPI.h>
#include <SD.h>
#include <EEPROM.h>
#include <Wire.h>

//#define DEBUG
//#define ULTRA_DEBUG
#define VERBOSE_PACKET
#define RTC_ENABLE  //Comment out if not using an RTC
#define DS1307_I2C_ADDRESS 0x68

#define NOP //Hai

const int ledPin = 13;
const int trialResetPin = 9;
const int trialNumAddr = 0;
const int chipSelect = 4;
const int maxTrialNum = 250;
const int delayConstant = 100000;  //Time to wait until data is collected, should change to a timer
const long microSecondsPerReading = 60000; //100000;  //This number should stay above ~60000

String filename;     //Global filename
short currentTrial;  //Value grabbed from EEPROM, determines the filename
//long microsInit;     //Contains initial micros() value, to help determine timing later
long milliInitTime;  //Contains initial millis() value
long initTime;       //Contains initial micros() value, to help determine timing later

void setup()
{
  #ifdef DEBUG
    Serial.begin(9600);
    Serial.println("[Arduino Init]");
    Serial.println("[SD Card Init]");
  #endif   
  pinMode(10, OUTPUT);        //Required for the Ethernet Shield's SD Card Reader
  pinMode(ledPin, OUTPUT);    //Indication
  digitalWrite(ledPin, LOW);  //LED default to off

  //Init card 
  if (!SD.begin(chipSelect)) {  //!!!TODO / Need some way of alerting user that the card failed to read
    #ifdef DEBUG
      Serial.println("[### Card Init Failed! ###]");
    #endif
    while(1){  //Supposed to signal user, but the Ethernet shield doesn't have an LED
      digitalWrite(ledPin, HIGH);
      delay(150);
      digitalWrite(ledPin, LOW);
      delay(150);
    }
  }
  #ifdef DEBUG
    Serial.println("[SD Card Init Successful]");
  #endif
  
  pinMode(trialResetPin, INPUT_PULLUP);  //"Pull down to reset"
  
  if( !digitalRead(trialResetPin) ){  //If trials need to be reset
    #ifdef DEBUG
      Serial.println("[Resetting Trial Number]");
    #endif 
    currentTrial = 1;
    EEPROM.write(trialNumAddr, currentTrial);
  }
  else {
    currentTrial = EEPROM.read(trialNumAddr);
    EEPROM.write(trialNumAddr, currentTrial + 1);    //Increment EEPROM for next time
  }
  
  //Check for too large of trial number (only up to 250 supported currently), overflows after that
  if(currentTrial >= maxTrialNum) {
    #ifdef DEBUG
      Serial.println("[#Trial too high, resetting... #]");
    #endif
    currentTrial = 1;
    EEPROM.write(trialNumAddr, currentTrial);
  }
  
  //Setup filename
  filename = "LOG";
  filename += String(currentTrial);
  filename += ".txt";
  
  //Add header to top of log file, also delete file if it exists already
  File dataFile = SD.open(filename.c_str(), FILE_WRITE);
  
  if (dataFile) {
    dataFile.println("Generated by \"AnalogLogger\" Arduino program. Contact Nick for details [nick@nickmccomb.net].");
    dataFile.println("Format: Trial Number, time (if RTC is enabled), Milliseconds (if RTC is enabled), Running seconds (if RTC is enabled), A0, A1, A2");
    dataFile.print("Current Settings: ");
    dataFile.print("Milliseconds per reading: ");
    dataFile.println(microSecondsPerReading / 1000);
  }
  
  dataFile.close();
  
  //Init Wire
  #ifdef RTC_ENABLE
    Wire.begin();
  #endif
  
  //Wait until the second has just passed
  byte second, minute, hour, dayOfWeek, dayOfMonth, month, year;
  getDateDs1307(&second, &minute, &hour, &dayOfWeek, &dayOfMonth, &month, &year);
  byte compSecond;
  
  do {  
    getDateDs1307(&compSecond, &minute, &hour, &dayOfWeek, &dayOfMonth, &month, &year);
  } while (compSecond == second);
  
  
  //Setup start time
  initTime = micros();
  milliInitTime = millis();
  
  #ifdef DEBUG
    Serial.println("[End Arduino Init]");
    Serial.print("[Current Trial: ");
    Serial.print(currentTrial);
    Serial.println("]");
  #endif
  
}

/*

Final output string:
currentTrial, time (if RTC is enabled), Milliseconds (if RTC is enabled), Running seconds (if RTC is enabled), A0, A1, A2

*/
void loop()
{
  //delayMicroseconds(delayConstant);
  
  String dataString = "";
  
  static long prevMeasure = initTime;
  static int secondsSinceInit = 0;  //Unused variable?
  
  dataString += String(currentTrial);
  dataString += ",";
  
  #ifdef RTC_ENABLE
  //Add current time to log

    static int iterPerSecondCounter = 0;
    static byte prevSecond = 70;
  
    byte second, minute, hour, dayOfWeek, dayOfMonth, month, year;
    
    getDateDs1307(&second, &minute, &hour, &dayOfWeek, &dayOfMonth, &month, &year);
    
    if(hour < 10)
      dataString += "0";
    dataString += String(hour);
    dataString += ":";
    if(minute < 10)
      dataString += "0";
    dataString += String(minute);
    dataString += ":";
    if(second < 10)
      dataString += "0";
    dataString += String(second);
    dataString += ",";
   
    if( second != prevSecond ){  //If the second has changed
      prevSecond = second;       //Set the new second
      iterPerSecondCounter = 0;  //Reset the counter
      ++secondsSinceInit;
    }
    else {                       //Otherwise, we need to continue counting
      ++iterPerSecondCounter;
    }
    
    int milliSeconds = (millis() - milliInitTime) % 1000;
    
    if(milliSeconds < 10)
      dataString += "0";
    
    if(milliSeconds < 100)
      dataString += "0";
    
    dataString += String(milliSeconds);
    dataString += ",";
    
    if (secondsSinceInit < 10)
      dataString += "0";
    
    if(secondsSinceInit < 100)
      dataString += "0";
    
    dataString += String(secondsSinceInit);
    dataString += ",";
    
    /* THE FOLLLOWING SECTION NEEDS WORK */
    //Add the counter to the stream
    //if(iterPerSecondCounter < 10)
    //  dataString += "0";
    //dataString += String( micros() -  );
    //dataString += String((int)(((float)iterPerSecondCounter*(float)microSecondsPerReading)/ 1000.0));  //We want to determine number of ms [THIS NUMBER IS INACCURATE]
    //dataString += ",";
    
    /*
    dataString += micros();
    dataString += ",";
    dataString += micros() - prevMeasure;
    dataString += ",";
    */
  #endif
  
  //Read three ADCs
  for (int analogPin = 0; analogPin < 3; analogPin++) {
    int data = analogRead(analogPin);
    dataString += String(data);
    if (analogPin < 2) {
      dataString += ",";
    }
  }

  /*
  dataString += ",";
  dataString += "potato";
  */
  
  File dataFile = SD.open(filename.c_str(), FILE_WRITE); //File object
   
  if (dataFile) { //If the file is available, output
    dataFile.println(dataString);
    dataFile.close();
    #ifdef DEBUG
      Serial.println(dataString); //Debug to the serial port
    #endif
  }
  else {  //Error state
    #ifdef DEBUG
      Serial.println("error opening datalog.txt");
    #endif
  }
  
  #ifdef ULTRA_DEBUG
    Serial.print("Cycle took: ");
    Serial.println((micros() - prevMeasure));
  #endif 
  
  //Wait until the timing is sufficiently okie dokie
  //Note, after about 70 minutes of running, the micros() will overflow, but this is 
  //okay, because then you get 0 - large number, which is negative, which will just 
  //result in a quick data point, not the end of the world.
  while ( (micros() - prevMeasure) < microSecondsPerReading) {
    //Serial.println((micros() - prevMeasure));
    NOP
  }
  prevMeasure = micros() - 1; //-1 to ensure we won't run into any problems
}



/* BEGIN RTC Helper Functions */
#ifdef RTC_ENABLE

// Convert normal decimal numbers to binary coded decimal
byte decToBcd(byte val)
{
  return ( (val/10*16) + (val%10) );
}
// Convert binary coded decimal to normal decimal numbers
byte bcdToDec(byte val)
{
  return ( (val/16*10) + (val%16) );
}

// Gets the date and time from the ds1307
void getDateDs1307(byte *second,
  byte *minute,
  byte *hour,
  byte *dayOfWeek,
  byte *dayOfMonth,
  byte *month,
  byte *year)
{
// Reset the register pointer
  Wire.beginTransmission(DS1307_I2C_ADDRESS);
  Wire.write(0);
  Wire.endTransmission();
  Wire.requestFrom(DS1307_I2C_ADDRESS, 7);
  // A few of these need masks because certain bits are control bits
  *second = bcdToDec(Wire.read() & 0x7f);
  *minute = bcdToDec(Wire.read());
  *hour = bcdToDec(Wire.read() & 0x3f); // Need to change this if 12 hour am/pm
  *dayOfWeek = bcdToDec(Wire.read());
  *dayOfMonth = bcdToDec(Wire.read());
  *month = bcdToDec(Wire.read());
  *year = bcdToDec(Wire.read());
}

#endif
/* END RTC Helper Functions */
